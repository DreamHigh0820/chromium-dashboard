{% extends "base.html" %}

{% block html_imports %}
  <link rel="import" href="/static/elements/chromedash-featurelist.html">
  <link rel="import" href="/static/elements/chromedash-metadata.html">
  <link rel="import" href="/static/elements/chromedash-legend.html">
{% endblock %}

{% block rss %}
<link href="features.xml" rel="alternate" type="application/rss+xml" title="All features" />
{% for k,v in categories %}
<link href="features.xml?category={{v}}" rel="alternate" type="application/rss+xml" title='"{{k}}" features' />
{% endfor %}

{% endblock %}

{% block css %}
<link rel="stylesheet" type="text/css" href="/static/css/features/features.css?2013-07-26">
{% endblock %}

{% block subheader %}
<div id="subheader">
  <!-- <div>
    <h2 title="Restrict search to a particular milestone">Filters</h2>
  </div> -->
  <div class="feature-count">
    <h2>Web Platform Features (<span id="num-features">-</span>)</h2>
  </div>
  <div class="search">
    <input type="search" placeholder="Search" disabled>
  </div> 
  <div class="actionlinks">
    {% if user.is_whitelisted %}<a href="/admin/features/new">Add a new feature</a>{% endif %}
    <a href="" class="legend">Help</a>
  </div>
</div>

{% endblock %}

{% block content %}
<!-- <div id="dialog" class="dialog polymer-overlay polymer-overlay-slideup">
  <h2>Legend</h2>
  <chromedash-legend></chromedash-legend>
  <button overlay-toggle>OK</button>
</div> -->

<chromedash-legend>
  <button overlay-toggle>Close</button>
</chromedash-legend>

<section id="panels">
<nav>
  <chromedash-metadata></chromedash-metadata>
</nav>
<chromedash-featurelist {% if user.is_whitelisted %}whitelisted{% endif %}></chromedash-featurelist>
</section>

<!--
{% load verbatim %}
{% verbatim %}
{% endverbatim %} -->

{% endblock %}

{% block js %}
<script>
(function() {
var $ = function(selector) {
  return document.querySelector(selector);
};
var $$ = function(selector) {
  return document.querySelectorAll(selector);
};

function updateCount(count) {
  $('#num-features').textContent = count;
}

document.addEventListener('WebComponentsReady', function(e) {
  var chromedashApp = $('chromedash-featurelist');
  var chromeMetadata = $('chromedash-metadata');
  var overlay = $('chromedash-legend');
  var search = $('.search [type="search"]');

  // Fill data from server by including it directly in template.
  chromedashApp.features = {{features|safe}};
  chromeMetadata.implStatuses = {{IMPLEMENATION_STATUSES|safe}};
  chromeMetadata.STATUS_KEYS = {
    NO_ACTIVE_DEV: 1,
    PROPOSED: 2,
    IN_DEVELOPMENT: 3,
    BEHIND_A_FLAG: 4,
    DEPRECATED: 8,
    ENABLED: 9
  };
  //chromedashApp.implStatuses = chromeMetadata.implStatuses;
  // chromedashApp.STATUS_KEYS = chromeMetadata.STATUS_KEYS;

  // // Instead, fill data via AJAX.
  // var xhr = new XMLHttpRequest();
  // xhr.open('GET', '/features.json');
  // xhr.onloadend = function(e) {
  //   chromedashApp.features = JSON.parse(e.target.response);
  // };
  // xhr.send();

  updateCount(chromedashApp.features.length); // Set initial # features showing.

  search.disabled = false;

  // Clear input when user clicks the 'x' button.
  search.addEventListener('input', function(e) {
    if (!e.target.value) {
      updateCount(chromedashApp.filter());
      //chromeMetadata.selected = null;
    } else {
      updateCount(chromedashApp.filter(e.target.value));
    }
  });

  chromeMetadata.addEventListener('filter-version', function(e) {
    var val = e.detail && e.detail.val || null;
    //search.value = e.detail.version;
    updateCount(chromedashApp.filter(val));
    //updateCount(chromedashApp.filterOnVersion(val));
  });

  chromedashApp.addEventListener('filter-category', function(e) {
    search.value = e.detail.val;
    updateCount(chromedashApp.filterOnCategory(e.detail.val));
  });

  overlay.views = {
    vendors: {{VENDOR_VIEWS|safe}}, // set from server
    webdevs: {{WEB_DEV_VIEWS|safe}} // set from server
  };

  $('.legend').addEventListener('click', function(e) {
    e.preventDefault();
    overlay.toggle();
  });

  document.body.addEventListener('keyup', function(e) {
    if (e.keyCode == 27) { // ESC
      updateCount(chromedashApp.filter());
      search.value = '';
      //chromeMetadata.selected = null;
    }
  });

  $('#content').addEventListener('scroll', function(e) {
    var feature = chromedashApp.featureInView(e.target.scrollTop);

    // If there's no shipped milestone, use the implementation status.
    var version = feature.shipped_milestone;
    if (!feature.shipped_milestone) {
      switch(feature.impl_status_chrome) {
        case chromeMetadata.implStatuses[chromeMetadata.STATUS_KEYS.NO_ACTIVE_DEV - 1].val:
        case chromeMetadata.implStatuses[chromeMetadata.STATUS_KEYS.PROPOSED - 1].val:
        case chromeMetadata.implStatuses[chromeMetadata.STATUS_KEYS.IN_DEVELOPMENT - 1].val:
          version = feature.impl_status_chrome;
          break;
        default:
          version = feature.shipped_milestone;
      }
    }

    // Update selection if it has changed.
    if (chromeMetadata.selected != version) {
      chromeMetadata.selected = version;

      // if (history.replaceState) {
      //   if (this.highlighted.name == 'hello')
      //     history.replaceState({}, "", " ");
      //   else
      //     history.replaceState({}, this.highlighted.name, this.highlighted.menu.href);
      // }
    }
  });

});

})();
</script>
{% endblock %}
