{% extends "base.html" %}
{% load verbatim %}
{% load inline_file %}

{% block css %}
  <style>{% inline_file "/static/css/schedule.css" %}</style>
{% endblock %}

{% block preload %}
  <script type="module">
    import 'https://unpkg.com/@polymer/paper-toggle-button/paper-toggle-button.js?module';
    import '/static/elements/chromedash-schedule.js';
  </script>
{% endblock %}

{% block subheader %}
  <div id="subheader">
    <!--<h2>Chrome release timeline</h2>-->
    <div style="flex:1">
      <h3>Release timeline</h3>
      <p class="description">Please note, all dates are estimates and are subject to change.</p>
    </div>
    <paper-toggle-button noink>Hide Blink components</paper-toggle-button>
  </div>
{% endblock %}

{% block content %}
  <section id="releases-section">
    <chromedash-schedule></chromedash-schedule>
  </section>
{% endblock %}

{% block js %}
  <script>
    (function() {
    'use strict';

    {% inline_file "/static/js/notifications.js" %}

    async function initNotifications(allFeatures) {
      await loadFirebaseSDKLibs(); // Lazy load Firebase messaging SDK.

      PushNotifications.init(); // init Firebase messaging.

      // If use already granted the notification permission, update state of the
      // push icon for each feature the user is subscribed to.
      const subscribedFeatures = await PushNotifications.getAllSubscribedFeatures();
      allFeatures.forEach((feature, i) => {
        if (subscribedFeatures.includes(String(feature.id))) {
          // f.receivePush = true;
          const iconEl = $(`[data-feature-id="${feature.id}"] .pushicon`);
          if (iconEl) {
            iconEl.icon = 'chromestatus:notifications';
          }
        }
      });
    }

    // async function getMilestoneInfo(version) {
    //   const resp = await fetch(`https://chromepmo.appspot.com/schedule/mstone/json?mstone=${version}`);
    //   const json = await resp.json();
    //   return json.mstones[0];
    // }

    // function currentChromeVersions(versions) {
    //   const channels = {};
    //   const winVersions = versions.filter(platform => platform.os === 'win')[0].versions;
    //   for (let i = 0, el; el = winVersions[i]; ++i) {
    //     channels[el.channel] = parseInt(el.version);
    //   }
    //   return channels;
    // }

    // const currentVersions = currentChromeVersions(versions);

    // getMilestoneInfo(currentVersions.stable).then(milestone => {
    //   t.set('channels.stable', Object.assign({
    //     version: currentVersions.stable
    //   }, milestone));

    //   document.body.classList.remove('loading');
    // });

    // getMilestoneInfo(currentVersions.beta).then(milestone => {
    //   t.set('channels.beta', Object.assign({
    //     version: currentVersions.beta
    //   }, milestone));
    // });

    // getMilestoneInfo(currentVersions.dev).then(milestone => {
    //   t.set('channels.dev', Object.assign({
    //     version: currentVersions.dev
    //   }, milestone));
    // });
    
    const url = location.hostname == 'localhost' ? 'https://www.chromestatus.com/features.json' :
                                                   '/features.json';
    const featuresPromise = fetch(url).then((res) => res.json());

    /**
     *  Returns the number of days between a and b.
     *  @param {!Date} a
     *  @param {!Date} b
     *  @return {!{days: number, future: boolean}}
     */
    function dateDiffInDays(a, b) {
      // Discard time and time-zone information.
      const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
      const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

      const MS_PER_DAY = 1000 * 60 * 60 * 24;
      const daysDiff = Math.floor((utc2 - utc1) / MS_PER_DAY);
      return {days: Math.abs(daysDiff), future: daysDiff < 1};
    }

    /**
     *  @param {!Array<!Object>} features
     */
    function sortFeaturesByName(features) {
      features.sort((a, b) => {
        a = a.name.toLowerCase();
        b = b.name.toLowerCase();
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      });
    }

    /**
     *  @param {!Array<!Object>} features
     */
    function mapFeaturesToComponents(features) {
      let set = new Set();
      features.forEach(f => set.add(...f.browsers.chrome.blink_components));
      const usedComponents = Array.from(set);

      const featuresMappedToComponents = {};
      features.forEach(f => {
        const components = f.browsers.chrome.blink_components;
        components.forEach(component => {
          if (!featuresMappedToComponents[component]) {
            featuresMappedToComponents[component] = [];
          }
          featuresMappedToComponents[component].push(f);
        });
      });

      for (let [component, feautreList] of Object.entries(featuresMappedToComponents)) {
        sortFeaturesByName(feautreList);
      }

      return featuresMappedToComponents;
    }

    t.channels = {{channels|safe}};

    $('paper-toggle-button').addEventListener('change', e => {
      e.stopPropagation();
      document.querySelectorAll('.release').forEach(release => {
        release.classList.toggle('no-components', e.target.checked)
      });
    });

    async function init() {
      document.body.classList.remove('loading');

      // Wait for Polymer to be setup before setting features on template.
      // This prevents race conditions whereby when opening a new tab, Chrome
      // returns features from the cache and beats Polymer being ready.
      const target = $('#releases-section');
      const mutationObserverPromise = new Promise(resolve => {
        const observer = new MutationObserver(mutations => {
          mutations.forEach(mutation => {
            if (mutation.addedNodes.length && target.querySelector('.releases')) {
              observer.disconnect();
              resolve();
            }
          });
        });
        observer.observe(target, {childList: true});
      });

      const timeoutPromise = new Promise(resolve => setTimeout(resolve, 5000));

      // Race fetching features from network and timeout. If MO observer check fails
      // for some reason, manually set features after 5s.
      await Promise.race([mutationObserverPromise, timeoutPromise]);

      const features = await featuresPromise;
      const stableFeatures = features.filter(f =>
          f.browsers.chrome.status.milestone_str === t.channels.stable.version);
      const betaFeatures = features.filter(f =>
          f.browsers.chrome.status.milestone_str === t.channels.beta.version);
      const devFeatures = features.filter(f =>
          f.browsers.chrome.status.milestone_str === t.channels.dev.version);

      t.set('channels.stable.components', mapFeaturesToComponents(stableFeatures));
      t.set('channels.beta.components', mapFeaturesToComponents(betaFeatures));
      t.set('channels.dev.components', mapFeaturesToComponents(devFeatures));

      // Show push notification icons if the browser supports the feature.
      if (window.PushNotifier && PushNotifier.SUPPORTS_NOTIFICATIONS) {
        $('.releases').classList.add('supports-push-notifications');
        initNotifications(features);
      }
    }

    document.addEventListener('WebComponentsReady', function(e) {
      const header = document.querySelector('app-header-layout app-header');
      if (header) {
        header.fixed = false;
      }
    });

    init();

  })();
  </script>
{% endblock %}
