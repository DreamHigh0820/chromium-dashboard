{% extends "base.html" %}

{% block html_imports %}
<!--<link id="features_import"
        rel="import"
        href="/static/elements/admin-imports{% if VULCANIZE %}.vulcanize{% endif %}.html"
        async>-->
<link rel="import" href="/static/elements/common.html">
<link rel="import" href="/static/elements/chromestatus-icons.html">
<link rel="import" href="/static/bower_components/iron-icon/iron-icon.html">
{% endblock %}

{% block css %}
<style>
  .no-push-notifications {
    display: none;
  }
  body[data-path*='notifications/tester'] #spinner {
    display: none;
  }
  ul {
    list-style: none;
  }
  #content section {
    margin-top: 16px;
  }
  [icon^="chromestatus:notifications"] {
    cursor: pointer;
  }
</style>
{% endblock %}

{% block subheader %}
<div id="subheader">
 Push notification tester
</div>
{% endblock %}

{% block content %}
<label>
  Feature id:
  <input id="feature_id" type="text" value="5827411627212800" placeholder="Feature id">
</label>
<button onclick="sendNotification()" disabled class="no-push-notifications">Send message</button>

<iron-icon icon="chromestatus:notifications-off" onclick="subscribeToFeature(this, '5827411627212800')" class="no-push-notifications"></iron-icon>

<section>
  <h3>Feature list</h3>
  <ul id="feature_list"></ul>
</section>

{% endblock %}

{% block js %}
<script src="https://www.gstatic.com/firebasejs/4.1.3/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.1.3/firebase-messaging.js"></script>

<script>
const SERVER_KEY = 'INSERT ME';
const SUPPORTS_NOTIFICATIONS = navigator.serviceWorker && window.Notification;

firebase.initializeApp({
  apiKey: "AIzaSyDMfRkOLG6OUTeEL_Z2ixEMDceyklm10UM",
  authDomain: "cr-status.firebaseapp.com",
  databaseURL: "https://cr-status.firebaseio.com",
  projectId: "cr-status",
  storageBucket: "cr-status.appspot.com",
  messagingSenderId: "999517574127"
});

const messaging = firebase.messaging();

async function getFeaturesList() {
  const url = '/features.json';
  const resp = await fetch(url);
  const json = await resp.json();
  return json;
}

async function getTokenInfo(token = null) {
  token = token || await getToken();

  try {
    const resp = await fetch(`https://iid.googleapis.com/iid/info/${token}?details=true`, {
      method: 'POST',
      headers: {
        'Authorization': `key=${SERVER_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        // details: true,
        // to: token,
      })
    });
    return await resp.json();
  } catch(err) {
    console.error('Error sending notification to FCM', err);
  }
}

getTokenInfo().then(info => {
  if (info.rel) {
    console.log(info.rel.topics);
  } else {
    console.log(info);
  }
});


async function sendNotification() {
  if (!SUPPORTS_NOTIFICATIONS) {
    throw Error('You browser does not support push notifications');
  }

  // const notification = {
  //   'title': 'Portugal vs. Denmark',
  //   'body': '5 to 1',
  //   'icon': '/static/img/crstatus_192.png',
  //   // 'badge': '/static/img/crstatus_192.png',
  //   // 'image': '/static/img/crstatus_192.png',
  //   'click_action': location.href
  // };

  // const token = await getToken();

  try {
    const resp = await fetch('/tasks/send_notifications', { //https://fcm.googleapis.com/fcm/send'
      method: 'POST',
      headers: {
        'Authorization': `key=${SERVER_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        // notification,
        // to: token,
        feature: {id: parseInt(document.getElementById('feature_id').value)}
      })
    });
  } catch(err) {
    console.error('Error sending notification to FCM', err);
  }
}

async function requestNotifications() {
  try {
    await messaging.requestPermission();
  } catch (err) {
    console.error('Unable to get permission to notify.', err);
  }
  return Notification.permission === 'granted';
}

async function getToken() {
  let currentToken;
  try {
    // Get Instance ID token. Initially this makes a network call, once retrieved
    // subsequent calls to getToken will return from cache.
    currentToken = await messaging.getToken();
  } catch (err) {
    console.log('An error occurred while retrieving token. ', err);
    setTokenSentToServer(false);
    return;
  }

  if (currentToken) {
    await sendTokenToServer(currentToken);
  } else {
    console.log('No Instance ID token available. Request permission to generate one.');
    // Prompt user to enable notifications.
    setTokenSentToServer(false);
    const granted = await requestNotifications();
    if (granted) {
      currentToken = await getToken();
    }
  }

  return currentToken;
}

// function deleteToken() {
//   // Delete Instance ID token.
//   // [START delete_token]
//   messaging.getToken()
//   .then(function(currentToken) {
//     messaging.deleteToken(currentToken)
//     .then(function() {
//       console.log('Token deleted.');
//       setTokenSentToServer(false);
//       // [START_EXCLUDE]
//       // Once token is deleted update UI.
//       // [END_EXCLUDE]
//     })
//     .catch(function(err) {
//       console.log('Unable to delete token. ', err);
//     });
//     // [END delete_token]
//   })
//   .catch(function(err) {
//     console.log('Error retrieving Instance ID token. ', err);
//   });
// }

function isTokenSentToServer() {
  return window.localStorage.getItem('pushTokenSentToServer') == 1;
}

function setTokenSentToServer(sent) {
  window.localStorage.setItem('pushTokenSentToServer', sent ? 1 : 0);
}

// Send the Instance ID token to the server, so we can:
// - send messages back to this app
// - subscribe/unsubscribe the token from topics
async function sendTokenToServer(token) {
  if (!isTokenSentToServer()) {
    const resp = await fetch('/features/push/new', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({subscriptionId: token})
    });

    setTokenSentToServer(true);
    console.log('Token sent to server.');
  }
}

messaging.onTokenRefresh(async () => {
  let refreshedToken;
  try {
    // Get Instance ID token. Initially this makes a network call. Once
    // retrieved, subsequent calls to getToken will return from the cache.
    refreshedToken = await messaging.getToken();
  } catch (err) {
    console.error('Unable to retrieve refreshed token ', err);
    return;
  }

  console.log('Token refreshed.');
  setTokenSentToServer(false);
  await sendTokenToServer(refreshedToken);
});

messaging.onMessage(payload => {
  const notification = new Notification(payload.notification.title, payload.notification);
  console.log(notification, payload);

  notification.onerror = function(e) {
    console.log(e);
  };

  notification.onclick = function(e) {
    //window.open(payload.notification.click_action, '_blank');
    window.focus();
  };
});

async function subscribeToFeature(icon, featureId) {
  const token = await getToken();

  try {
    const resp = await fetch(`https://iid.googleapis.com/iid/v1/${token}/rel/topics/${featureId}`, {
      method: 'POST',
      headers: {
        'Authorization': `key=${SERVER_KEY}`,
        'Content-Type': 'application/json'
      }
    });
  } catch(err) {
    console.error('Error sending notification to FCM', err);
  }

  const info = await getTokenInfo(token);
  console.log(info);

  const active = icon.classList.toggle('active');
  if (active) {
    icon.icon = 'chromestatus:notifications';
  } else {
    icon.icon = 'chromestatus:notifications-off';
  }
}

function useId(el) {
  document.getElementById('feature_id').value = el.dataset.id;
}

if (SUPPORTS_NOTIFICATIONS) {
  document.querySelectorAll('.no-push-notifications').forEach(el => {
    el.classList.remove('no-push-notifications');
    el.disabled = false;
  });
  // navigator.serviceWorker.ready.then(reg => {
    // messaging.useServiceWorker(reg); // use site's existing sw instead of the one FB messaging registers.

    // getToken().then(token => {
    //   // console.log(token);
    // });
  // });

  getFeaturesList().then(features => {
    const list = document.querySelector('#feature_list');
    features.forEach(f => {
      const li = document.createElement('li');
      li.innerHTML = `${f.name}: <a href="#" onclick="useId(this)" data-id="${f.id}">${f.id}</a>`;
      list.appendChild(li);
    });
  });
}
</script>
{% endblock %}
