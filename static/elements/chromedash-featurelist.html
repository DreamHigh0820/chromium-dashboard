<link rel="import" href="chromedash-feature.html">

<polymer-element name="chromedash-featurelist" attributes="whitelisted features">
<template>
  <link rel="stylesheet" type="text/css" href="../css/elements/chromedash-featurelist.css">
  <template repeat="{{feature in filtered}}">
    <li is="chromedash-feature" feature="{{feature}}">
      <template if="{{whitelisted}}">
        <a href="/admin/features/edit/{{feature.id}}" class="edit">edit</a>
      </template>
    </li>
  </template>
</template>
<script>
  Polymer('chromedash-featurelist', {
    applyAuthorStyles: true,
    whitelisted: false,
    ready: function() {
      this.asyncMethod(function() {
        this.features = this.features || [];
        this.featureLiList = this.featureLiList || [];
        this.filterd = this.filterd || [];
      });
    },
    featuresChanged: function() {
      this.filter();
      this.asyncMethod(function() {
        this.featureLiList = this.shadowRoot.querySelectorAll('li');
      });
    },
    filterOnCategory: function(val) {
      var regex = new RegExp(val, 'ig');
      this.filtered = this.features.filter(function(feature, idx, array) {
        return regex.test(feature.category);
      });
      return this.filtered.length;
    },
    // filterOnVersion: function(val) {
    //   var regex = new RegExp(val, 'ig');
    //   this.filtered = this.features.filter(function(feature, idx, array) {
    //     return regex.test(feature.category);
    //   });
    //   return this.filtered.length;
    // },
    filter: function(val) {
      // Clear filter if there's no search or if called directly.
      if (!val) {
        this.filtered = this.features;
      } else {
        val = val.trim();

        // Returns operator and version query e.g. ["<=25", "<=", "25"].
        var result = /^([<>=]=?)\s*?([0-9]+)/.exec(val);
        if (result) {
          var operator = result[1];
          var version = parseInt(result[2]);
          this.filtered = this.features.filter(function(feature, idx, array) {
            var shipped_milestone = parseInt(feature.shipped_milestone);

            switch(operator) {
              case '<':
                return shipped_milestone < version;
                break;
              case '<=':
                return shipped_milestone <= version;
                break;
              case '>':
                return shipped_milestone > version;
                break;
              case '>=':
                return shipped_milestone >= version;
                break;
              case '=': // Support both '=' and '=='.
              case '==':
                return version == shipped_milestone;
                break;
              default:
                return false;
            }
          });
        } else {
          // Remove "=" prefix so "in development"/"proposed" version queries
          // return results.
          if (val.indexOf('=') == 0) {
            val = val.substring(1);
          }
          var regex = new RegExp(val, 'ig');
          this.filtered = this.features.filter(function(feature, idx, array) {
            return regex.test(feature.name) || regex.test(feature.category) ||
                   regex.test(feature.summary) ||
                   /*regex.test(feature.shipped_milestone) ||*/
                   regex.test(feature.impl_status_chrome);
          });
        }
      }

      return this.filtered.length;
    },
    // Returns the closest feature <li> to the scroll top position passed in.
    featureInView: function(containerScrollTop) {
      var closest = null;

      for (var i = 0, feature; feature = this.featureLiList[i]; ++i) {
        var dist = feature.offsetTop - containerScrollTop;
        if (dist < 0) {
          dist = -dist * 1.5;
        }

        if (closest == null || dist < closest.dist) {
          closest = this.features[i];
          closest.dist = dist;
        }
      }
      return closest;
    }
  });
</script>
</polymer-element>