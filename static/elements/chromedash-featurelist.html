<link rel="import" href="chromedash-feature.html">

<polymer-element name="chromedash-featurelist" attributes="whitelisted features">
<template>
  <link rel="stylesheet" type="text/css" href="../css/elements/chromedash-featurelist.css">
  <ul>
    <template repeat="{{feature in filtered}}">
      <div firstofmilestone?="{{feature.firstOfMilestone}}" data-milestone="{{feature.shipped_milestone || feature.impl_status_chrome}}"></div>
      <li is="chromedash-feature" feature="{{feature}}" data-milestone="{{feature.shipped_milestone || feature.impl_status_chrome}}" needsflag="{{feature.meta.needsflag}}">
        <a href="/admin/features/edit/{{feature.id}}" class="edit" hidden?="{{!whitelisted}}">edit</a>
      </li>
    </template>
  </ul>
</template>
<script>
(function() {
  function onMetadataChanged_(e) {
    this.scrollToMilestone(e.detail.version);
  }

  Polymer('chromedash-featurelist', {
    applyAuthorStyles: true,
    whitelisted: false,
    metadata: null,
    ready: function() {
      //this.asyncMethod(function() {
        this.features = this.features || [];
        this.featureLiList = this.featureLiList || [];
        this.filterd = this.filterd || [];
      //});

      this.addEventListener('scroll', function(e) {
        var feature = this.featureInView(e.target.scrollTop);
        this.metadata.selectMilestone(feature);

        // // Update URL with history API.
        // if (history.replaceState) {
        //   if (this.highlighted.name == 'hello')
        //     history.replaceState({}, "", " ");
        //   else
        //     history.replaceState({}, this.highlighted.name, this.highlighted.menu.href);
        // }
      });
    },
    metadataChanged: function(oldVal) {
      // TODO: probably need to remove the listener if metadata element changes.
      //this.metadata.removeEventListener('milestoneselect', onMetadataChanged_.bind(this));
      this.metadata.addEventListener('milestoneselect', onMetadataChanged_.bind(this));

      // TODO(ericbidelman): figure out more efficient way to do this.
      this.metadata.addEventListener('metadataready', function(e) {
        for (var i = 0, version; version = this.metadata.versions[i]; ++i) {
          var idx = this.firstOfMilestone(version, i);
          if (idx != -1) {
            this.features[idx].firstOfMilestone = true;
          }
        }
      }.bind(this));
    },
    featuresChanged: function() {
      this.filter();

      this.asyncMethod(function() {
        this.featureLiList = this.shadowRoot.querySelectorAll('li');

        // Highlight and scroll to first "in development" when list of features changes.
        // TODO: really want this in ready(), but featureLiList and metadata may
        // not be set yet. Timing issues.
        this.scrollToMilestone(this.metadata.implStatuses[
            this.metadata.STATUS_KEYS.IN_DEVELOPMENT - 1].val);
      });
    },
    filterOnCategory: function(val) {
      var regex = new RegExp(val, 'ig');
      this.filtered = this.features.filter(function(feature, idx, array) {
        return regex.test(feature.category);
      });
      return this.filtered.length;
    },
    // filterOnVersion: function(val) {
    //   var regex = new RegExp(val, 'ig');
    //   this.filtered = this.features.filter(function(feature, idx, array) {
    //     return regex.test(feature.category);
    //   });
    //   return this.filtered.length;
    // },
    // filteredChanged: function() {
    //   this.featureLiList = this.shadowRoot.querySelectorAll('li');
    // },
    filter: function(val) {
      // Clear filter if there's no search or if called directly.
      if (!val) {
        this.filtered = this.features;
      } else {
        val = val.trim();

        // Returns operator and version query e.g. ["<=25", "<=", "25"].
        var result = /^([<>=]=?)\s*?([0-9]+)/.exec(val);
        if (result) {
          var operator = result[1];
          var version = parseInt(result[2]);
          this.filtered = this.features.filter(function(feature, idx, array) {
            var shipped_milestone = parseInt(feature.shipped_milestone);

            switch(operator) {
              case '<':
                return shipped_milestone < version;
                break;
              case '<=':
                return shipped_milestone <= version;
                break;
              case '>':
                return shipped_milestone > version;
                break;
              case '>=':
                return shipped_milestone >= version;
                break;
              case '=': // Support both '=' and '=='.
              case '==':
                return version == shipped_milestone;
                break;
              default:
                return false;
            }
          });
        } else {
          // Remove "=" prefix so "in development"/"proposed" version queries
          // return results.
          if (val.indexOf('=') == 0) {
            val = val.substring(1);
          }
          var regex = new RegExp(val, 'ig');
          this.filtered = this.features.filter(function(feature, idx, array) {
            return regex.test(feature.name) || regex.test(feature.category) ||
                   regex.test(feature.summary) ||
                   /*regex.test(feature.shipped_milestone) ||*/
                   regex.test(feature.impl_status_chrome);
          });
        }
      }

      return this.filtered.length;
    },
    // Returns the closest feature <li> to the scroll top position passed in.
    featureInView: function(containerScrollTop) {
      var closest = null;

      for (var i = 0, li; li = this.featureLiList[i]; ++i) {
        var dist = li.offsetTop - containerScrollTop;
        if (dist < 0) {
          dist = -dist * 1.5;
        }

        if (closest == null || dist < closest.dist) {
          closest = this.features[i];
          closest.dist = dist;
        }
      }
      return closest;
    },
    // Returns the index of the first feature of a given milestone string.
    firstOfMilestone: function(milestone, opt_startFrom) {
      var start = opt_startFrom == undefined ? 0 : opt_startFrom;
      for (var i = start, feature; feature = this.features[i]; ++i) {
        // Check shipped milestone and impl status. Ensure comparing strings.
        if ([String(feature.shipped_milestone),
             feature.impl_status_chrome].indexOf(String(milestone)) != -1) {
          return i;
        }
      }
      return -1;
    },
    scrollToMilestone: function(milestone) {
      var idx = this.firstOfMilestone(milestone);
      if (idx != -1) {
        this.featureLiList[idx].scrollIntoView(true);
        //this.featureLiList[idx].scrollIntoViewIfNeeded();
      }
    }
  });
})();
</script>
</polymer-element>